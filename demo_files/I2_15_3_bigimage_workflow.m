%% 大規模画像の効率的な処理
% この例は、bigimageの機能を使って、大規模画像を効率的に処理するサンプルコードです。
% 大規模画像に対してのアルゴリズム検討の効率化、および検討したアルゴリズムの適用の効率化について示します。
% 本例では簡単な画像処理の例として、画像の2値化処理を適用しますが、より高度な画像処理も同様の考え方で行うことができます。
% Copyright 2020 The MathWorks, Inc.
clear, close all, clc;
%% 画像の読み込み
bim = bigimage('tumor_091R.tif');
%% 画像の表示
bigimageshow(bim);
%% アルゴリズム検討の効率化
%% 方法1. 低解像レベルでのアルゴリズムの検討
% 最低解像レベルの画像を取り出す
imLowRes = getFullLevel(bim, bim.CoarsestResolutionLevel);
imLowResGray = rgb2gray(imLowRes);
% しきい値の計算
thresh1 = graythresh(imLowResGray);
imLowResQuant = imbinarize(imLowResGray,thresh1);
imshow(imLowResQuant)
%% 方法2. 最高解像レベルにおいてROIを設定してのアルゴリズムの検討
% ROIにズーム
bigimageshow(bim);
xlim([2400,3300])
ylim([900 1700])
% ROIの抜き出し
xrange = xlim;
yrange = ylim;
imRegion = bim.getRegion(1,[xrange(1),yrange(1)],[xrange(2),yrange(2)]);
imshow(imRegion);
% ROIでのしきい値計算
imRegionGray = rgb2gray(imRegion);
thresh2 = graythresh(imRegionGray); % このしきい値を使う場合は75行目にてthresh1->thresh2への変更が必要
imLowResQuant = ~imbinarize(imRegionGray,thresh2);

imshow(imLowResQuant)
%% マスクの作成
% 次に処理を適用する範囲を決めるマスクを作成します。
% ここでは大まかに捉えられていればよしとします。
BW = createMask(imLowRes); % 色のしきい値アプリで作成

width = 7;
se = strel('disk', width);
BW = imclose(BW, se);
BW = bwareafilt(BW, [1e3 Inf]);
imshow(BW)
% maskをbigimageへ変換
bmask = bigimage(BW, 'SpatialReferencing', bim.SpatialReferencing(bim.CoarsestResolutionLevel));
%% maskの表示
h = bigimageshow(bim);
h.Parent.Color = 'g';
h.Parent.Alphamap = [1 .5];
h.AlphaData = bmask;
h.AlphaDataMapping = 'direct';
%% ブロックの中でのROIのカバー率に応じて、処理するかどうかを調節する
% デフォルト（0.5）、0.4、0とカバー率を変えて結果を観察する。
h = bigimageshow(bim);
showmask(h,bmask,1);
title('Mask with Default Inclusion Threshold')
snapnow
%%
showmask(h,bmask,1,'InclusionThreshold',0.4);
title('InclusionThreshold == 0.4')
%%
showmask(h,bmask,1,'InclusionThreshold',0);
title('InclusionThreshold == 0')
%% ブロックサイズの調整
% ブロックサイズが大きく、無駄が多いため、ブロックサイズを小さくする。
% ただし小さくしすぎるとブロック化のオーバーヘッドにより、逆に処理時間がかかってしまう。
blockSize = [512 512];
h = bigimageshow(bim);
showmask(h,bmask,1,'BlockSize',blockSize,'InclusionThreshold',0);
title(['BlockSize == [' num2str(blockSize) '], InclusionThreshold == 0'])
%% ブロック単位での処理の実行
tic
bq = apply(bim, bim.FinestResolutionLevel,...
    @(im)~imbinarize(rgb2gray(im), thresh1), ...
    'Mask',bmask,'BlockSize',blockSize,'InclusionThreshold',0);
time1 = toc;
bigimageshow(bq,'CDataMapping','scaled');
title('ROIが含まれるブロックのみの実行結果');
% 比較として、画像の全範囲で計算
tic
bq = apply(bim, bim.FinestResolutionLevel,...
    @(im)~imbinarize(rgb2gray(im), thresh1));
time2 = toc;
% 計算時間の確認
fprintf("画像の全範囲で計算すると%5.3f秒かかりましたが、マスクを含むブロックのみ処理すると%5.3f秒でした。\n", ...
    time2, time1);

%% support function
function [BW,maskedRGBImage] = createMask(RGB)
%createMask  Threshold RGB image using auto-generated code from colorThresholder app.
%  [BW,MASKEDRGBIMAGE] = createMask(RGB) thresholds image RGB using
%  auto-generated code from the colorThresholder app. The colorspace and
%  range for each channel of the colorspace were set within the app. The
%  segmentation mask is returned in BW, and a composite of the mask and
%  original RGB images is returned in maskedRGBImage.

% Auto-generated by colorThresholder app on 30-Mar-2020
%------------------------------------------------------


% Convert RGB image to chosen color space
I = rgb2hsv(RGB);

% Define thresholds for channel 1 based on histogram settings
channel1Min = 0.633;
channel1Max = 0.246;

% Define thresholds for channel 2 based on histogram settings
channel2Min = 0.083;
channel2Max = 1.000;

% Define thresholds for channel 3 based on histogram settings
channel3Min = 0.000;
channel3Max = 0.863;

% Create mask based on chosen histogram thresholds
sliderBW = ( (I(:,:,1) >= channel1Min) | (I(:,:,1) <= channel1Max) ) & ...
    (I(:,:,2) >= channel2Min ) & (I(:,:,2) <= channel2Max) & ...
    (I(:,:,3) >= channel3Min ) & (I(:,:,3) <= channel3Max);
BW = sliderBW;

% Initialize output masked image based on input image.
maskedRGBImage = RGB;

% Set background pixels where BW is false to zero.
maskedRGBImage(repmat(~BW,[1 1 3])) = 0;

end
